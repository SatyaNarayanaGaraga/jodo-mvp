<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLASHFLOW | CV Fruit Ninja Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            background-color: #050505;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        #video-feed {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            transform: scaleX(-1); /* Mirror effect */
            z-index: 1;
            opacity: 0.3;
            border-radius: 12px;
            border: 2px solid #333;
            object-fit: cover;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }

        .score-box {
            font-size: 2.5rem;
            color: #0ff;
        }

        .lives-box {
            font-size: 2.5rem;
            color: #ff0055;
            letter-spacing: 5px;
        }

        /* Combo Indicator */
        #combo-display {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 4rem;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 20px #ff6600;
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s;
        }

        .combo-active {
            opacity: 1 !important;
            transform: translateX(-50%) scale(1.2) !important;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 4rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        p {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 2rem;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        #loading-spinner {
            border: 4px solid #333;
            border-top: 4px solid #0ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="game-container">
    <video id="video-feed" autoplay playsinline muted></video>
    <canvas id="game-canvas"></canvas>

    <!-- UI Overlay (HUD) -->
    <div id="ui-layer">
        <div class="hud">
            <div class="score-box">SCORE: <span id="score-val">0</span></div>
            <div id="combo-display">x0 COMBO</div>
            <div class="lives-box" id="lives-val">‚ù§‚ù§‚ù§</div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>SLASHFLOW</h1>
        <div id="loading-spinner"></div>
        <p id="status-text">Initializing Vision Engine...</p>
        <p style="font-size: 0.9rem; color: #666;">Requires Camera Access. Stand back ~1 meter.</p>
        <button id="start-btn" class="btn hidden">INITIATE</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #ff0055; background: none; -webkit-text-fill-color: #ff0055;">SYSTEM FAILURE</h1>
        <p>FINAL SCORE: <span id="final-score" style="color: white; font-size: 2rem;">0</span></p>
        <button id="restart-btn" class="btn">REBOOT SYSTEM</button>
    </div>
</div>

<!-- Audio Logic -->
<script>
    // --- AUDIO SYSTEM (Synthesized) ---
    const AudioSys = {
        ctx: null,
        init: () => {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            AudioSys.ctx = new AudioContext();
        },
        playSlice: (velocity, combo) => {
            if (!AudioSys.ctx) return;
            const osc = AudioSys.ctx.createOscillator();
            const gain = AudioSys.ctx.createGain();
            
            // Pitch scales with velocity AND combo
            // Higher combo = sharper, more satisfying sound
            const comboBoost = Math.min(500, combo * 50);
            const pitch = Math.min(1200, 200 + (velocity * 15) + comboBoost);
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(pitch, AudioSys.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, AudioSys.ctx.currentTime + 0.15);
            
            gain.gain.setValueAtTime(0.1, AudioSys.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + 0.15);
            
            osc.connect(gain);
            gain.connect(AudioSys.ctx.destination);
            osc.start();
            osc.stop(AudioSys.ctx.currentTime + 0.15);
        },
        playBomb: () => {
            if (!AudioSys.ctx) return;
            const osc = AudioSys.ctx.createOscillator();
            const gain = AudioSys.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, AudioSys.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, AudioSys.ctx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.5, AudioSys.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + 0.5);
            osc.connect(gain);
            gain.connect(AudioSys.ctx.destination);
            osc.start();
            osc.stop(AudioSys.ctx.currentTime + 0.5);
        }
    };
</script>

<!-- Vision & Game Logic -->
<script type="module">
import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm/index.mjs";

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const video = document.getElementById('video-feed');
const scoreEl = document.getElementById('score-val');
const livesEl = document.getElementById('lives-val');
const comboEl = document.getElementById('combo-display');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const statusText = document.getElementById('status-text');
const loadingSpinner = document.getElementById('loading-spinner');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');
const finalScoreEl = document.getElementById('final-score');

let handLandmarker = undefined;
let webcamRunning = false;
let lastVideoTime = -1;
let lastHandTime = 0; // For velocity normalization

// Game State
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
let score = 0;
let lives = 3;
let width, height;
let time = 0;
let difficultyMultiplier = 1;
let hitStop = 0; // Freeze frame counter

// Combo System
let combo = 0;
let comboTimer = 0;
const COMBO_WINDOW = 80; // Frames before combo drops

// Hand Tracking State
let handPos = { x: 0, y: 0, active: false };
let handHistory = []; // For trail
let velocity = 0;
const VELOCITY_THRESHOLD = 6; // Normalized velocity threshold
const TRAIL_LENGTH = 10;

// Entities
let fruits = [];
let particles = [];
let floaters = []; // Combo text

// --- VISION SETUP ---

async function createHandLandmarker() {
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
    );
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1
    });
    statusText.innerText = "Vision System Online";
    loadingSpinner.style.display = "none";
    startBtn.classList.remove('hidden');
}

createHandLandmarker();

// --- GAME OBJECTS ---

const FRUIT_TYPES = {
    WATERMELON: { color: '#ef5350', rind: '#2e7d32', radius: 40, points: 1, label: 'üçâ' },
    BANANA:     { color: '#ffeb3b', rind: '#fbc02d', radius: 35, points: 1, label: 'üçå' },
    APPLE:      { color: '#ff1744', rind: '#b71c1c', radius: 30, points: 1, label: 'üçé' },
    ORANGE:     { color: '#ff9800', rind: '#e65100', radius: 32, points: 1, label: 'üçä' },
    BOMB:       { color: '#212121', rind: '#ff0000', radius: 45, points: 0, isBomb: true, label: 'üí£' },
    ICE:        { color: '#00e5ff', rind: '#fff', radius: 30, points: 5, type: 'ice', label: '‚ùÑÔ∏è' }
};

class Fruit {
    constructor() {
        this.reset();
    }

    reset() {
        this.active = true;
        this.sliced = false;
        // Spawn closer to center
        this.x = width * 0.2 + Math.random() * (width * 0.6); 
        this.y = height + 50;
        
        // Physics
        this.vx = (Math.random() - 0.5) * 8; 
        this.vy = -(15 + Math.random() * 8 + (difficultyMultiplier * 2)); 
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.2;
        this.gravity = 0.4;

        // Type selection
        const rand = Math.random();
        if (rand < 0.15) this.data = FRUIT_TYPES.BOMB;
        else if (rand < 0.20) this.data = FRUIT_TYPES.ICE; 
        else if (rand < 0.4) this.data = FRUIT_TYPES.BANANA;
        else if (rand < 0.6) this.data = FRUIT_TYPES.APPLE;
        else if (rand < 0.8) this.data = FRUIT_TYPES.ORANGE;
        else this.data = FRUIT_TYPES.WATERMELON;

        this.isPart = false;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.rotation += this.rotSpeed;

        if (this.y > height + 100 && !this.sliced) {
            this.active = false;
        }
    }

    draw(ctx) {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        if (this.isPart) {
            ctx.beginPath();
            ctx.arc(0, 0, this.data.radius, Math.PI, 0); 
            ctx.fillStyle = this.data.color;
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = this.data.rind;
            ctx.stroke();
        } else {
            ctx.beginPath();
            ctx.arc(0, 0, this.data.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.data.rind;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 0, this.data.radius - 4, 0, Math.PI * 2);
            ctx.fillStyle = this.data.color;
            ctx.fill();

            ctx.font = `${this.data.radius}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillText(this.data.label, 0, 5);
            
            if (this.data.isBomb) {
                ctx.beginPath();
                ctx.moveTo(this.data.radius * 0.5, -this.data.radius * 0.5);
                ctx.quadraticCurveTo(this.data.radius, -this.data.radius * 1.5, this.data.radius + 10, -this.data.radius);
                ctx.strokeStyle = '#eca400';
                ctx.lineWidth = 3;
                ctx.stroke();
                if (Math.random() > 0.5) {
                    ctx.fillStyle = '#ffeb3b';
                    ctx.fillRect(this.data.radius + 8, -this.data.radius - 2, 4, 4);
                }
            }
        }
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 15;
        this.vy = (Math.random() - 0.5) * 15;
        this.life = 1.0;
        this.decay = 0.03 + Math.random() * 0.03;
        this.size = Math.random() * 8 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.vy += 0.2;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Floater {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 1.0;
        this.vy = -2;
    }
    update() {
        this.y += this.vy;
        this.life -= 0.02;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.font = "900 24px 'Orbitron'";
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

// --- GAME LOGIC ---

function spawnFruit() {
    const spawnRate = Math.min(0.03, 0.008 + score * 0.0003);
    if (Math.random() < spawnRate) {
        fruits.push(new Fruit());
    }
    if (score > 50 && Math.random() < 0.001) {
        for(let i=0; i<3; i++) fruits.push(new Fruit());
    }
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function distToSegment(px, py, x1, y1, x2, y2) {
    const l2 = (x2-x1)**2 + (y2-y1)**2;
    if (l2 === 0) return Math.hypot(px-x1, py-y1);
    let t = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2;
    t = Math.max(0, Math.min(1, t));
    const cx = x1 + t*(x2-x1);
    const cy = y1 + t*(y2-y1);
    return Math.hypot(px-cx, py-cy);
}

function handleSlice(fruit, index) {
    if (fruit.sliced) return;
    if (handHistory.length < 2) return;
    
    const p1 = handHistory[handHistory.length - 2];
    const p2 = handHistory[handHistory.length - 1];
    
    const d = distToSegment(fruit.x, fruit.y, p1.x, p1.y, p2.x, p2.y);

    if (d < fruit.data.radius + 10) { 
        
        // Bomb Check
        if (fruit.data.isBomb) {
            if (velocity > VELOCITY_THRESHOLD * 1.5) {
                AudioSys.playBomb();
                lives--;
                combo = 0; // Reset combo on hit
                updateHUD();
                createExplosion(fruit.x, fruit.y, '#fff');
                fruits.splice(index, 1);
                
                document.body.style.backgroundColor = '#330000';
                setTimeout(() => document.body.style.backgroundColor = '#050505', 100);

                if (lives <= 0) gameOver();
            }
            return;
        }

        // --- SUCCESSFUL SLICE ---
        hitStop = 4; 
        
        // Combo Logic
        combo++;
        comboTimer = COMBO_WINDOW;
        
        // Score Calculation (Base + Combo Bonus)
        const bonus = combo > 1 ? combo : 0;
        score += fruit.data.points + bonus;

        AudioSys.playSlice(velocity, combo);
        fruit.sliced = true;
        updateHUD();

        // Split
        const p1Obj = new Fruit();
        p1Obj.x = fruit.x; p1Obj.y = fruit.y;
        p1Obj.vx = -5; p1Obj.vy = -5;
        p1Obj.data = fruit.data;
        p1Obj.isPart = true;
        p1Obj.rotation = fruit.rotation;
        
        const p2Obj = new Fruit();
        p2Obj.x = fruit.x; p2Obj.y = fruit.y;
        p2Obj.vx = 5; p2Obj.vy = -5;
        p2Obj.data = fruit.data;
        p2Obj.isPart = true;
        p2Obj.rotation = fruit.rotation;

        fruits.push(p1Obj, p2Obj);
        fruits.splice(index, 1);
        
        createExplosion(fruit.x, fruit.y, fruit.data.color);
        
        // Floater Text
        let txt = "+1";
        let col = "#fff";
        if (combo > 1) {
            txt = `${combo}x COMBO!`;
            col = "#ffd700";
        }
        floaters.push(new Floater(fruit.x, fruit.y, txt, col));
        
        if (fruit.data.type === 'ice') {
            difficultyMultiplier = 0.5;
            document.body.style.backgroundColor = '#003333';
            setTimeout(() => {
                difficultyMultiplier = 1;
                document.body.style.backgroundColor = '#050505';
            }, 3000);
        }
    }
}

function updateHUD() {
    scoreEl.innerText = score;
    livesEl.innerHTML = '‚ù§'.repeat(lives);
    
    if (combo > 1) {
        comboEl.innerText = `x${combo} COMBO`;
        comboEl.classList.add('combo-active');
        // Reset animation trigger
        comboEl.style.animation = 'none';
        comboEl.offsetHeight; /* trigger reflow */
        comboEl.style.animation = null; 
    } else {
        comboEl.classList.remove('combo-active');
    }
}

function gameOver() {
    gameState = 'GAMEOVER';
    finalScoreEl.innerText = score;
    gameOverScreen.classList.remove('hidden');
    startBtn.innerText = "PLAY AGAIN";
    fruits = [];
    particles = [];
}

function resetGame() {
    score = 0;
    lives = 3;
    combo = 0;
    gameState = 'PLAYING';
    hitStop = 0;
    updateHUD();
    gameOverScreen.classList.add('hidden');
    startScreen.classList.add('hidden');
}

// --- MAIN LOOP ---

function detectHand() {
    if (!webcamRunning) return;

    const nowInMs = Date.now();
    const performanceNow = performance.now();

    if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        const dt = performanceNow - lastHandTime;
        lastHandTime = performanceNow;

        if (handLandmarker) {
            const results = handLandmarker.detectForVideo(video, nowInMs);
            if (results.landmarks && results.landmarks.length > 0) {
                const landmarks = results.landmarks[0];
                const indexTip = landmarks[8];
                
                const targetX = (1 - indexTip.x) * width; 
                const targetY = indexTip.y * height;

                const dx = targetX - handPos.x;
                const dy = targetY - handPos.y;
                const rawDist = Math.sqrt(dx*dx + dy*dy);

                if (dt > 0) {
                    velocity = (rawDist / dt) * 16.67; 
                } else {
                    velocity = 0;
                }

                handPos.x += (targetX - handPos.x) * 0.8;
                handPos.y += (targetY - handPos.y) * 0.8;
                handPos.active = true;

                handHistory.push({x: handPos.x, y: handPos.y});
                if (handHistory.length > TRAIL_LENGTH) handHistory.shift();

            } else {
                handPos.active = false;
                velocity = 0;
                handHistory = [];
                // If hand lost, break combo
                // combo = 0; // Optional: strict mode
            }
        }
    }
    requestAnimationFrame(detectHand);
}

function render() {
    ctx.fillStyle = 'rgba(5, 5, 5, 0.9)'; 
    ctx.fillRect(0, 0, width, height);

    if (hitStop > 0) {
        hitStop--;
        for (let f of fruits) f.draw(ctx);
        for (let p of particles) p.draw(ctx);
        for (let fl of floaters) fl.draw(ctx);
        drawBlade();
        requestAnimationFrame(render);
        return;
    }

    // Combo Timer Decay
    if (gameState === 'PLAYING') {
        spawnFruit();
        if (combo > 0) {
            comboTimer--;
            if (comboTimer <= 0) {
                combo = 0;
                updateHUD();
            }
        }
    }

    for (let i = fruits.length - 1; i >= 0; i--) {
        const f = fruits[i];
        f.update();
        f.draw(ctx);
        
        if (gameState === 'PLAYING' && handPos.active && velocity > VELOCITY_THRESHOLD) {
            handleSlice(f, i);
        }
        if (!f.active) fruits.splice(i, 1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw(ctx);
        if (p.life <= 0) particles.splice(i, 1);
    }

    for (let i = floaters.length - 1; i >= 0; i--) {
        const f = floaters[i];
        f.update();
        f.draw(ctx);
        if (f.life <= 0) floaters.splice(i, 1);
    }

    drawBlade();
    requestAnimationFrame(render);
}

function drawBlade() {
    if (handPos.active && handHistory.length > 2) {
        ctx.beginPath();
        ctx.moveTo(handHistory[0].x, handHistory[0].y);
        for (let i = 1; i < handHistory.length; i++) {
                ctx.lineTo(handHistory[i].x, handHistory[i].y);
        }

        // DYNAMIC BLADE COLOR BASED ON COMBO
        if (velocity > VELOCITY_THRESHOLD * 1.5) {
            ctx.strokeStyle = '#d500f9'; // Purple (Speed)
        } else if (combo > 6) {
            ctx.strokeStyle = '#ffd700'; // Gold (High Combo)
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ffd700';
        } else if (combo > 3) {
            ctx.strokeStyle = '#00ff00'; // Green (Med Combo)
        } else if (velocity > VELOCITY_THRESHOLD) {
            ctx.strokeStyle = '#00ffff'; // Cyan (Normal)
        } else {
            ctx.strokeStyle = '#555';
        }

        if (velocity > VELOCITY_THRESHOLD) {
             ctx.lineWidth = 6 + (combo * 0.5); // Blade gets thicker with combo
             ctx.shadowBlur = 15 + (combo * 2);
             ctx.shadowColor = ctx.strokeStyle;
        } else {
            ctx.lineWidth = 3;
            ctx.shadowBlur = 0;
        }

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(handPos.x, handPos.y, 4, 0, Math.PI * 2);
        ctx.fill();
    }
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
}

window.addEventListener('resize', resize);
resize();

startBtn.addEventListener('click', async () => {
    AudioSys.init(); 
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: 1280, height: 720, frameRate: { ideal: 60 } } 
        });
        video.srcObject = stream;
        video.addEventListener("loadeddata", () => {
            webcamRunning = true;
            lastHandTime = performance.now();
            resetGame();
            
            // Fix: Hide start screen immediately upon load
            startScreen.classList.add('hidden');
            statusText.innerText = "Camera Active ‚Äî Start Slicing";
            
            detectHand();
        });
    } catch (e) {
        alert("Camera access denied or error: " + e.message);
    }
});

restartBtn.addEventListener('click', resetGame);
render();

</script>
</body>
</html>
